<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <title>Blog Article Copenhagen</title>
    <meta name="description" content="Blog Article Copenhagen">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="css/main.css">
</head>
<body>
<div class="autoreload">
    <label for="autoreload">
        <input type="checkbox" id="autoreload">
        auto reload
    </label>
</div>
<!-- ARTICLE START -->
<p>
    Hi, I'm Patrick, software engineer at mobile.de. My team and I work on <a href="http://www.mobile.de">mobile.de</a>, which is Germany's biggest online marketplace for cars and other vehicles.
</p>
<p>
    In June 2015, we were given a task that every software developer dreams of: throw away all the old stuff and rewrite everything from scratch. The “old stuff” being the public German home page of mobile.de, the main entry point of our platform.
</p>

<figure>
    <a href="./data/mediapool/mobile.de-before-relaunch_825x710.png" target="_blank"><img src="./data/mediapool/mobile.de-before-relaunch_557x478.png" alt="mobile.de before the relaunch" width="557" height="478"></a>
    <figcaption>mobile.de before...</figcaption>
</figure>

<figure>
    <a href="./data/mediapool/mobile.de-after-relaunch_1013x755.png" target="_blank"><img src="./data/mediapool/mobile.de-after-relaunch_700x522.png" alt="mobile.de after the relaunch" width="700" height="522"></a>
    <figcaption>...and after the relaunch</figcaption>
</figure>

<br><br><br>
<br><br><br>
<br><br><br>

<p>We have, traditionally been a Java shop since we migrated from a big steaming pile of Perl back in 2007, but engineers at mobile.de are encouraged to explore new technologies and empowered to choose the best tool for the task at hand.</p>

<p>At the time we started planning our team included three JavaScript experts (including myself) and one Java expert.</p>

<p>Our system architecture has evolved from monilithic to service-oriented in the last year or so. The home page is pretty simple, a thin layer between a handful of service APIs and the client-side code. <a href="https://nodejs.org/">Node.js</a> is really good at integrating services and passing data through to the presentation layer, so it was an obvious choice.</p>

<figure>
    <img src="./data/mediapool/plan-h-architecture_573x517.png" alt="A thin layer" width="573" height="517">
</figure>

<p>It was not hard to convince the Powers That Be<sup>TM</sup>, as well as the one Java developer on our team, that we should go for Node.js, which is still fairly new technology for us.</p>


<br><br><br>
<br><br><br>
<br><br><br>

<h2>Promise-driven Service Integration With Axios</h2>

<p>As I've mentioned before, the Copenhagen web app is basically a backend layer between the client and a handful of microservices. How to go about integrating those services? The requests to the services happen asynchronously, which is always fun to implement and the default way Node.js handles things.</p>

<p>For example, we have an advertising service that gives us all the code snippets to be integrated on the page, that display all those colorful ads that our users love so much &#128522;</p>

<figure>
    <img src="./data/mediapool/advertising-service_700x422.png" alt="Advertising service" width="700" height="422">
    <figcaption>Advertising service</figcaption>
</figure>

<p>I don't have to explain about <a href="http://callbackhell.com/">callback hell</a>, the dreaded tangle of nested callback functions. There are much better ways to handle asynchronous calls, and ES6 comes with two of them built in, namely <a href="https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promises</a> and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator">Generators</a>. I have to admit it, I have not yet quite wrapped my head around Generators, despite reading excellent articles about it like the one by <a href="http://davidwalsh.name/es6-generators">Kyle Simpson</a>.</p>

<p>Promises are easier to grasp: you create a Promise that is resolved or rejected after the async magic has happened (in this case, after JSON data has been loaded from the advertising service – or not). Then you create a chain of things that happen afterwards, using the <a href="https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Promise#then%28%29">then method</a>. To handle errors, you add a <a href="https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Promise#catch%28%29">catch method</a> to the chain.

<p>Our controller code that uses a client component for accessing the advertising service looks like this:</p>

<iframe src="http://pahund.github.io/blog-article-copenhagen/code-example-axios-controller.html" frameBorder="0"  width="100%" height="220" scrolling="no" seamless></iframe>

<p>As you can see, for each request a new client of type <em>Advertising</em> is instantiated that gets the current request and response (line 3).</p>

<p>It has a <em>get</em> method that does the asynchronous fetching of JSON data from the service (line 4).</p>

<p>The first <em>then</em> that is attached to the Promise returned by <em>get</em> adds the data to the model to be passed to the view (line 5).</p>

<p>The second <em>then</em> method renders the page (line 6).

<p>If things go awry and there is an error or a timeout, the <em>catch</em> method lets the <em>Advertising</em> instance handle the error (basically just logging it) and then also renders the page – without advertising, but yet fully functional (line 7).</p>

<p>To send the actual request to the server, the <em>Advertising</em> instance uses <a href="https://github.com/mzabriskie/axios">Axios</a>, a promise-based HTTP client by Matt Zabriskie, which I found quite charming at the time.</p>

<p>Alas, when it was time to integrate another service that channels traffic between the desktop site and the mobile-optimized site, we hit a road block. Our channeling service expected the user agent header of the API request to be the one of the browser accessing the frontend, but Axios always sets the UA to its own, special user agent string.</p>

<p>It's a known issue that <a href="https://github.com/mzabriskie/axios/issues/69">other developers have also come accross</a>. The author of Axios fixed it, but he hadn't released a new npm module version with the fix until after the launch of our project. So we were stuck with a <em>package.json</em> file that looked like this:</p>

<iframe src="http://pahund.github.io/blog-article-copenhagen/code-example-axios-package-json.html" frameBorder="0"  width="100%" height="81"></iframe>

<br><br><br>
<br><br><br>
<br><br><br>


<h2>Monitoring and Logging</h2>
<p>
    We have roughly 7.29 unique users per month<sup>1</sup>, so the website gets a lot of traffic (about 40 requests per second). If we screw up, there's thousands people left out in the cold. So it's essential the the servers run smoothly – and if things do go awry, there is proper monitoring in place that immediately alerts us and proper logging to quickly find out what went wrong. My colleague <a href="http://twitter.com/https://twitter.com/jonykrause">Jonathan Krause</a> will go into detail on this in another blog article coming soon to this station.
</p>
<h2>Acknowledgements</h2>
<ul>
    <li><a href="https://en.wikipedia.org/wiki/Food_photography#/media/File:Ice_cubes_openphoto.jpg">Ice Cubes by Darren Hester</a></li>
</ul>
<p>
    <hr>
    <small>
        <sup>1</sup> AGOF internet facts 05-2015
    </small>
</p>
<!-- ARTICLE END -->
<script src="js/main.js"></script>
</body>
</html>
